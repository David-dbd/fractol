<p align="center">
  <a href="README.md">üá™üá∏ Espa√±ol</a> ‚Ä¢ <a href="README.en.md">üá∫üá∏ English</a>
</p>

---

# Fractol

**Fractol** is a C project that renders fractals in real time using the **MiniLibX** library and concepts of complex mathematics.
It implements fractals such as **Mandelbrot**, **Julia**, and **Burning Ship**, which are generated by applying iterations over complex numbers for each pixel on the screen.

---

## üìö Theory and Context

A **fractal** is a set defined by a mathematical iteration.
We start from the general formula:

$$
Z_{n+1} = Z_n^2 + C
$$

Where **Z** and **C** are complex numbers of the form $x + yi$.
If, when iterated repeatedly, $|Z|$ exceeds **2**, the point is said to *escape*.
Otherwise, if it stays bounded until the maximum number of iterations, it belongs to the fractal.

For optimization, we replace `sqrt` and `pow` with **complex algebra**:

$$
(x + yi)^2 = (x^2 - y^2) + 2xyi
$$

And check for escape with:

$$
|Z|^2 = x^2 + y^2
$$

If $x^2 + y^2 > 4$, the point escapes, avoiding expensive calculations.

---

## ‚öôÔ∏è Rendering Steps

### 1Ô∏è‚É£ Initialize the visual interface with `mlx_init`

**Code:**

```c
void *mlx = mlx_init();
```

**Description:**
Initializing the MiniLibX library is the first step because it allows us to connect to the operating system‚Äôs graphics server. Without this initialization, we cannot create windows or images in memory.
Basically, `mlx_init()` sets the **graphics context** that will handle all resources during the program‚Äôs lifetime. From this point on, every drawing operation, window creation, and image creation will depend on this `mlx` pointer.

---

### 2Ô∏è‚É£ Create the window and the image

**Code:**

```c
void *win = mlx_new_window(mlx, WIDTH, HEIGHT, "Fractol");
void *img = mlx_new_image(mlx, WIDTH, HEIGHT);
```

**Description:**
The **window** is the visible area where the fractal will ultimately be displayed.
The **image** is different: it is a **memory buffer** where we draw pixel by pixel before rendering it on the screen.
This approach avoids flickering and gives us full control over colors. Each image pixel takes **4 bytes (RGBA)**, allowing us to manipulate colors precisely.

---

### 3Ô∏è‚É£ Get the image buffer with `mlx_get_data_addr`

**Code:**

```c
char *ptr_buf_img;
int bpp, size_l, endian;
ptr_buf_img = mlx_get_data_addr(img, &bpp, &size_l, &endian);
```

**Description:**
In this step, we directly access the **memory block** where the image resides.

* `bpp` tells us how many bits each pixel takes (usually 32)
* `size_l` is the number of bytes in each row
* `ptr_buf_img` is the pointer to the first byte of the buffer

By working at the byte level, we can write colors without depending on external functions, pixel by pixel, using pointer arithmetic.
This also allows us to optimize performance and have precise control over the final image.

---

### 4Ô∏è‚É£ Map each pixel to the complex plane

**Description:**
Each pixel `(px, py)` in the window must be converted to a complex number `(x + yi)` to evaluate the fractal formula.
To do this, we define a **viewport** that corresponds to the area where the fractal is visible.
For example, for Mandelbrot:

* Real: `[-2.0, 1.0]`
* Imaginary: `[-1.5, 1.5]`

We then **linearly scale** the pixel position to this range.
Thus, each point on the screen becomes a unique complex number to be evaluated.

---

### 5Ô∏è‚É£ Iterate the formula $Z^2 + C$ and determine escape

**Description:**
Here we apply the **core iteration** of fractals:

$$
Z_{n+1} = Z_n^2 + C
$$

We expand the square using complex algebra:

* Real: $x^2 - y^2 + Re(C)$
* Imaginary: $2xy + Im(C)$

We repeat this until:

1. $x^2 + y^2 > 4$ ‚Üí the point escapes
2. Or we reach the maximum number of iterations ‚Üí the point is considered inside the fractal

This loop is the **heart of the project**, as it defines the final shape of the fractal on the screen.

---

### 6Ô∏è‚É£ Assign color based on the iteration

**Description:**
Once we determine whether the point escapes, we choose a color.

* If it does **not escape**, the pixel is painted **black** to represent that it belongs to the fractal.
* If it escapes, we assign a color based on the iteration at which it escaped.

Example with a maximum of 100 iterations:

* Low iteration ‚Üí light colors (escapes quickly)
* High iteration ‚Üí darker colors (close to the limit)

This gradient creates the **visual depth** that makes fractals recognizable.

---

### 7Ô∏è‚É£ Write the pixel to the buffer

**Code:**

```c
int offset = y * size_l + x * (bpp / 8);
*(int *)(ptr_buf_img + offset) = color;
```

**Description:**
To paint a pixel, we calculate its **byte offset** within the buffer:

* Multiply the row (`y`) by the row size (`size_l`)
* Add the column (`x`) multiplied by the bytes per pixel (`bpp / 8`)

Then we write the color as a 4-byte integer.
This method gives us direct control over memory and allows for very fast drawing.

---

### 8Ô∏è‚É£ Display the image and keep the loop running

**Code:**

```c
mlx_put_image_to_window(mlx, win, img, 0, 0);
mlx_loop(mlx);
```

**Description:**
When all pixels have been calculated and colored, we copy the image to the window‚Äôs **framebuffer** with `mlx_put_image_to_window`.
Then, `mlx_loop` keeps the program running and handles events such as:

* **Zoom with the mouse**
* **Movement with the keyboard**
* **Window closing**

Each time we interact, we can recalculate the fractal and redraw it dynamically.

---

## üîÅ Summary Flow

1. Initialize MLX
2. Create window and image
3. Get image buffer
4. Map each pixel to a complex number
5. Iterate $Z^2 + C$ with complex algebra
6. Determine escape and assign color
7. Write color to the buffer
8. Display image and keep the loop running

---

## üöÄ How to Use

### Clone the repository

```bash
git clone <repository_url>
cd fractol
```

### Compile the project

```bash
make
```

### Run the program

```bash
./fractol <fractal_type> [coordinates]
```

**Examples:**

```bash
./fractol mandelbrot
./fractol burningship
./fractol julia -0.7 0.5675
./fractol julia -0.8 0.156
./fractol julia 0.285 0
```

**Available fractal types:**

* `mandelbrot`
* `burningship`
* `julia` *(requires two coordinates between -2.0 and 2.0)*

---

If the user enters an **invalid argument**, the program displays help:

```
Invalid input from user

Available input:

* Type of fractal: Julia - Mandelbrot - Burningship

* If you choose Julia, then add:
  one coordinate separated by space.

* Examples:
  ./fractol julia -0.7 0.5675
  ./fractol julia -0.8 0.156
  ./fractol julia -0.4 0.6
  ./fractol julia -0.75 0.11
  ./fractol julia 0.285 0

* Please note values can go from -2.0 to 2.0
